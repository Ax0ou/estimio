class LlmService
  def initialize(transcript: nil)
    @description = transcript || section.description
  end

  def extract_raw_json(content)
    content.gsub(/```json|```/, "").strip
  end

  def call

    chat = RubyLLM.chat(model: 'google/gemini-2.5-flash-preview-05-20', provider: 'openrouter', assume_model_exists: true)
    chat.add_message(content: @description, role: "user")
    response = chat.with_instructions(system_prompt).ask(@description)

    clean_content = sanitize_llm_response(response.content)
    JSON.parse(clean_content)
    rescue JSON::ParserError => e
    Rails.logger.error("‚ùå Erreur de parsing JSON : #{e.message}")
    { error: 'Invalid JSON', raw: response.content }
  end

  private

  def sanitize_llm_response(content)
    # Supprime les d√©limitations Markdown √©ventuelles comme ```json ou ```
    content.gsub(/```json|```/, "").strip
  end

  def system_prompt
    <<~PROMPT
      ‚úÖ Contexte
      - Il n'est **pas n√©cessaire de poser des questions suppl√©mentaires**.
      - Il n'est **pas n√©cessaire de valider ou reformuler** la demande.
      - Ta seule mission est de proposer une premi√®re estimation sous forme structur√©e.
      - Ce r√©sultat sera ensuite corrig√© √† la main par l'utilisateur dans l'interface.

      üßæ Format de r√©ponse attendu :
      √Ä partir de la description suivante "#{@description}", g√©n√®re un JSON brut.

      Chaque √©l√©ment du tableau (line item) doit contenir :
      - description : description pr√©cise du travail/mat√©riau
      - quantity : quantit√© estim√©e (nombre)
      - unit : unit√© appropri√©e ("u", "m¬≤", "ml", "h", "m¬≥", "kg")
      - price_per_unit : prix unitaire en euros

      Unit√©s √† utiliser :
      "u"     => "unit√©",
      "m¬≤"    => "m√®tre carr√©",
      "h"     => "heure",
      "kg"    => "kilogramme",
      "m¬≥"    => "m√®tre cube",
      "j"     => "jour",
      "g"     => "gramme",
      "t"     => "tonne",
      "l"     => "litre",
      "m"     => "m√®tre"

      Dans un premier temps, consulte la base de donn√©es de produits de l'artisan pour r√©cup√©rer les prix unitaires des mat√©riaux et services courants.
      Voici la liste #{Product.pluck(:name, :price, :unit).map { |name, price, unit| "#{name} (#{price} ‚Ç¨/#{unit})" }.join(', ')}

      Exemple attendu :
      üßæ Format de r√©ponse attendu :
      √Ä partir de la description suivante "#{@description}", g√©n√®re un JSON brut.
      Exemple attendu, il faut absolument qu'il y ait ces trois √©l√©ments, quantity et price_per_unit ainsi que la description. Assure-toi qu'il y ait une bonne logique de quantit√© entre si c'est des mat√©riaux ou si c'est des heures.
        Dans le json, Chaque √©l√©ment du tableau (line item) doit contenir un champ section_id identique pour toutes les lignes, correspondant √† l'identifiant unique de la section trait√©e.
        [
          {
            "description": "Pose de carrelage",
            "quantity": 20,
            "unit": "m¬≤",
            "price_per_unit": 80
          },
          {
            "description": "Main d'≈ìuvre pose",
            "quantity": 4,
            "unit": "h",
            "price_per_unit": 50
          }
        ]
    PROMPT
  end
end
